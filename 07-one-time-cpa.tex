\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}

\usepackage{amsthm,amsmath,amsfonts,amssymb,amstext,enumitem}
\usepackage{latexsym,ifthen,url,rotating,graphicx}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning,fit}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}



% --- -----------------------------------------------------------------
% --- Document-specific definitions.
% --- -----------------------------------------------------------------
\lstset{
    columns=fixed,
    literate={—}{{---}}1 {…}{{...}}1
}

\newcommand{\todo}[1]{{\color{red}[TODO:{#1}]}}

\newtheorem{problem}{Problem}
\newtheorem{corollary}{Corollary}
\newtheorem{fact}{Fact}
\newtheorem{exercise}{Exercise}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{lemma}{Lemma}
\newtheorem{example}{Example}

\newcommand{\getsr}
  {{\:\stackrel{\raisebox{-2pt}{${\scriptscriptstyle \hspace{0.2em}\$}$}}
   {\leftarrow}\:}}
\newcommand{\points}[1]{\textbf{({#1} pts)}}

\newcommand{\fn}{\footnotesize}
\newcommand{\Colon}{\ : \ }
\newcommand{\st}{\mathsf{state}}
\newcommand{\msgs}{\mathcal{M}}
\newcommand{\ctxts}{\mathcal{C}}
\newcommand{\keys}{\mathcal{K}}
\newcommand{\rands}{\mathcal{R}}
\newcommand{\states}{\mathcal{S}}
\newcommand{\kg}{\mathcal{K}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\MAC}{\mathrm{MAC}}
\newcommand{\RMAC}{\mathrm{RMAC}}

\newcommand{\pk}{pk}
\newcommand{\sk}{sk}

\newcommand{\calD}{\mathcal{D}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\AES}{\mathsf{AES}}

\newcommand{\algorithm}[1]{\textbf{Alg} {#1}}

\newcommand{\calO}{\mathcal{O}}

\newcommand{\dlog}{\mathrm{dlog}}

\newcommand{\Adv}{\mathbf{Adv}}
\newcommand{\AdvPRF}[2]{\Adv^{\mathrm{prf}}_{#1}({#2})}
\newcommand{\AdvPRG}[2]{\Adv^{\mathrm{prg}}_{#1}({#2})}
\newcommand{\AdvCPA}[2]{\Adv^{\mathrm{ind{-}cpa}}_{#1}({#2})}
\newcommand{\AdvCCA}[2]{\Adv^{\mathrm{ind{-}cca}}_{#1}({#2})}
\newcommand{\AdvKR}[2]{\Adv^{\mathrm{kr}}_{#1}({#2})}
\newcommand{\AdvCKR}[2]{\Adv^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\AdvRMR}[2]{\Adv^{\mathrm{rmr}}_{#1}({#2})}
\newcommand{\AdvCR}[2]{\Adv^{\mathrm{cr}}_{#1}({#2})}
\newcommand{\AdvUFCMA}[2]{\Adv^{\textrm{uf{-}cma}}_{#1}({#2})}
\newcommand{\AdvDL}[2]{\Adv^{\mathrm{dl}}_{#1}({#2})}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\ExpOW}[1]{\Exp^{\mathrm{ow}}({#1})}
\newcommand{\ExpCKR}[2]{\Exp^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\ExpRMR}[2]{\Exp^{\mathrm{rmr}}_{#1}({#2})}

\newcommand{\concat}{{\,\|\,}}
\newcommand{\xor}{\oplus}
\newcommand{\bits}{\{0,1\}}

\newcommand{\tcolh}{T^{\mathrm{col}}_h}
\newcommand{\tcolH}{T^{\mathrm{col}}_{H^2}}
\newcommand{\Hcomb}{H^{1\|2}}
\newcommand{\Hxor}{H^{1\oplus2}}

\newcommand{\EXP}{\textrm{EXP}}
\newcommand{\MODEXP}{\textrm{MOD{-}EXP}}
\newcommand{\ADD}{\textrm{ADD}}
\newcommand{\MULTIMODEXP}{\textrm{MULTI{-}MOD{-}EXP}}
\newcommand{\MUL}{\textrm{MUL}}
\newcommand{\MOD}{\textrm{MOD}}

\newcommand{\GG}{\mathbb{G}}
\newcommand{\ZZ}{\mathbb{Z}}

\newcommand{\bK}{\mathbf{K}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bC}{\mathbf{C}}

\newcommand{\rvrange}{\mathcal{R}}
\newcommand{\rspace}{\mathcal{C}}

\newcommand{\hatalpha}{\hat{\alpha}}
\newcommand{\hatb}{\hat{b}}

\newcommand{\barm}{\overline{m}}

\newcommand{\otp}{\mathrm{OTP}}
\newcommand{\des}{\mathrm{DES}}
\newcommand{\twodes}{\mathrm{2DES}}
\newcommand{\threedes}{\mathrm{3DES}}
\newcommand{\threedestwo}{\mathrm{3DES2}}
\newcommand{\aes}{\mathrm{AES}}
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}


\newcommand{\Img}{\mathrm{Im}}

\newcommand{\Expt}{\mathbf{Expt}}
\newcommand{\ExptOTCPA}{\mathbf{Expt}^{\mathrm{1\mbox{-}cpa}}}
\newcommand{\ExptOTCPAone}{\mathbf{Expt}^{\mathrm{1\mbox{-}cpa\mbox{-}1}}}
\newcommand{\ExptOTCPAzero}{\mathbf{Expt}^{\mathrm{1\mbox{-}cpa\mbox{-}0}}}
\newcommand{\AdvOTCPA}[2]{\Adv^{\mathrm{1\mbox{-}cpa}}_{#1}({#2})}
\newcommand{\ExptCPAone}{\mathbf{Expt}^{\mathrm{cpa\mbox{-}1}}}
\newcommand{\ExptCPAzero}{\mathbf{Expt}^{\mathrm{cpa\mbox{-}0}}}

\newcommand{\Piotp}{\Pi_\mathrm{otp}}
\newcommand{\Encotp}{\Enc_\mathrm{otp}}
\newcommand{\Decotp}{\Dec_\mathrm{otp}}
\newcommand{\bhat}{\hat{b}}
% --- -----------------------------------------------------------------
% --- Lecture notes formatting macros
% --- -----------------------------------------------------------------

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\newcounter{lecnum}
%\renewcommand{\thepage}{\thelecnum-\arabic{page}}
\renewcommand{\thesection}{\thelecnum.\arabic{section}}
\renewcommand{\theexercise}{\thelecnum.\arabic{exercise}}
\renewcommand{\theexample}{\thelecnum.\arabic{example}}
\renewcommand{\thedefinition}{\thelecnum.\arabic{definition}}
\renewcommand{\theequation}{\thelecnum.\arabic{equation}}
\renewcommand{\thefigure}{\thelecnum.\arabic{figure}}
\renewcommand{\thefact}{\thelecnum.\arabic{fact}}
\renewcommand{\thetable}{\thelecnum.\arabic{table}}


%
% The following macro is used to generate the header.
%
\newcommand{\lecture}[2]{
   %\pagestyle{myheadings}
   %\thispagestyle{plain}
   \newpage
   \setcounter{lecnum}{#1}
   \setcounter{page}{1}
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CMSC 28400 Introduction to Cryptography
                        \hfill Autumn 2019} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill #2 \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { {\it Instructor: David Cash} \hfill }
      \vspace{2mm}}
   }
   \end{center}
   %\markboth{Lecture #1: #2}{Lecture #1: #2}
   \vspace*{4mm}
}





% --- -----------------------------------------------------------------
% --- The document starts here.
% --- -----------------------------------------------------------------
\begin{document}
%\lecture{**LECTURE-NUMBER**}{**DATE**}{**LECTURER**}{**SCRIBE**}
\lecture{7}{Notes \#7: One-Time CPA Security for Encryption}

\tableofcontents

\noindent\hrulefill
\bigskip

\section{Analyzing the Security of Encryption}

Are any of the constructions from the last section \emph{secure}? If so, can we
say that some are \emph{more secure} than others? The old approach to answering
these sorts of questions, dating back to the birth of cryptography, is to
think about how the constructions might be used and to look for attacks. In
practice this approach is effective for some types of problems, and is still
important today; In future sets of notes we'll look at encryption security
from that point of view.

Since about the 1980's, another approach has been developed that extends
Shannon's idea of giving \emph{mathematical definitions} of security. For
better or worse, this approach is called ``provable security.'' 
We have seen a bit of this already in our analysis of stream ciphers, when
we used a definition of pseudorandom generator distinguishing advantage.

At a high level, the provable security approach works in three distinct steps:
(1) Defining security goals, (2) Defining computational assumptions, and (3)
Proving security via reductions.  Each of these steps involves idiosyncrasies
that will be discussed in turn.

In these notes we begin this process, identifying an initial definition
and exploring its implications.

\subsection{Defining Security Goals}

Find a definition of ``security'' that enumerates what an adversary is allowed
to do and how much computational effort it my expend.  In this step we seek to
formalize something like 
{\quote{ \emph{``The adversary may mount a chosen-plaintext attack, and employ
any algorithmic strategy in $2^{100}$ time to analyze ciphertexts to learn
about plaintexts it does not know.''} }}
\smallskip

The salient features of this informal definition include the adversary
capabilities (chosen-plaintext attack), a time bound ($2^{100}$), and a goal
(learning about plaintexts that it does not know). Also central to this
approach is that we want to allow \emph{any} algorithmic strategy, including
ones we don't know about ourselves. This is remarkable because the current
state of theoretical computer science is not very good at reasoning about the
limits of general time-bounded algorithms. This situation is very similar to
that of pseurorandom generators, where we wanted to think only of time-bounded
distinguishers failing, but we have no real tools for proving anything
conclusive about them.

\section{One-Time Chosen-Plaintext Security of Encryption}

With that said, let's just run through a definition and interpret it later.  
In this definition, the symbol $\calA$ refers to an ``algorithm'', which we
think of informally; It's an entity that can be ``run'', with or without
input. It has some internal persistent memory, and the next time it is run
it will ``remember'' everything it has seen.

The definition uses the notation $x\getsr X$ to mean ``select a random
sample from the set $X$, and call it $x$.''
\begin{definition}
    Let $\Pi = (\Enc,\Dec)$ be a deterministic encryption scheme with key-space
    $\keys$, message-space $\msgs$, and ciphertext-space $\ctxts$. 
    We assume that the message-space $\msgs$ is a set of bit strings, i.e.
    $\msgs\subseteq\bits^*$.
    Let $\calA$
    be an algorithm. Define algorithm $\ExptOTCPA_\Pi(\calA)$ as
    \begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\ExptOTCPA_\Pi(\calA)$}} \\[2pt]
            \fn01 \> Run $\calA$, which produces $(m_0,m_1)\in\msgs$\\
            \fn02 \> If $m_0$ and $m_1$ are different lengths: Output $0$\\
            \fn03 \> Pick $k\getsr \keys, b\getsr \bits$\\
            \fn 04 \> Compute $c \gets \Enc(k,m_b)$ and run $\calA(c)$, which
            produces $\hatb\in\bits$\\
            \fn05\> If $\hatb = b$: Output 1\\
            \fn06 \> Else: Output 0
        \end{tabbing}\end{minipage}
    \end{tabular}
    \end{center}
    Define the \emph{one-time CPA advantage of $\calA$ against $\Pi$} as
    \[
        \AdvOTCPA{\Pi}{\calA} =
        \left|\Pr[\ExptOTCPA_\Pi(\calA) = 1] - \frac{1}{2}\right|
    \]
\end{definition}
The algorithm $\ExptOTCPA_\Pi(\calA)$ should be thought of as a
``test-harness'' for $\calA$. This algorithm is not something we would ever
use in practice, as it does not nothing useful other than evaluate a
potential adversary $\calA$. As with pseudorandom generators,
the advantage $\AdvOTCPA{\Pi}{\calA}$ is a ``score'', this time between $0$ and
$1/2$; The higher the advantage, the better the adversary.

Most of the complexity is in this definition is in $\ExptOTCPA_\Pi(\calA)$.
Intuitively, the experiment has $\calA$ declare two messages that it would like
to be challenged on. If $\calA$ chooses messages of different lengths, then it
automatically loses (because the experiment outputs $0$, which means the
adversary has lost). Otherwise, the experiment picks a random key and a bit
$b$, and encrypts $m_b$ under the chosen key and hands the ciphertext back to
the adversary. The adversary then outputs its guess $\hatb$: Intuitively it is
trying to determine which message was encrypted, and $\hatb$ represents which
message it thinks was more likely to be encrypted. If correct, the
experiment indicates a win by outputting $1$, and otherwise it indicates
a loss with $0$.

Note that even a very simple $\calA$ can win with probability $1/2$, say
by always outputting $0$. The goal of the adversary is to do better
than that. In practice, an adversary running in time (say) $2^{100}$
and achieving $\AdvOTCPA{\Pi}{\calA} = 1/2^{100}$ may be considered
a ``break,'' depending on the exact parameters like key-length.

\begin{example}
    Let $\Pi=(\Enc,\Dec)$ be ECB encryption with AES. We give an efficient
    $\calA$ such that $\AdvOTCPA{\Pi}{\calA} = 1/2$. It works as follows:
    \begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{Adversary $\calA$} \\[2pt]
            \fn01 \> Output $m_0 = 0^{128}\|0^{128}, m_1=0^{128}\|1^{128}$.\\
            \fn02 \> On input $c$, parse $c[1]\|c[2]\gets c$, where
            $c[1],c[2]\in\bits^{128}$ \\
            \fn03 \> If $c[1]=c[2]$: Output $\bhat=0$\\
            \fn04 \> Else: Output $\bhat=1$.
        \end{tabbing}\end{minipage}
    \end{tabular}
    \end{center}
    Let's check that $\Pr[\ExptOTCPA_\Pi(\calA) = 1]=1$. If $b=0$,
    then the message $m_0=0^{128}\|0^{128}$ will be encrypted, and
    we will have $c[1]=c[2]$ and $\calA$ will output $\bhat=0$.
    If $b=1$ then we'll get that $\calA$ outputs $\bhat=1$ instead,
    because $c[1]=\aes(k,0^{128})\neq\aes(k,1^{128})=c[2]$.
    Thus $\bhat=b$ with probability $1$.
\end{example}

The next example shows that good one-time CPA security implies it is hard
to compute the first bit of a message from a ciphertext.
\begin{example}
    Let $\Pi=(\Enc,\Dec)$ be a some deterministic encryption scheme
    with $\msgs=\bits^{128}$.
    Suppose $\calA$ has the property that for all $k\in\keys,m\in\msgs$,
    $\calA(\Enc(k,m))$ outputs the first bit of $m$. Consider the
    following adversary $\calB$:
    \begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{Adversary $\calB$} \\[2pt]
            \fn01 \> Output $m_0 = 0^{128}, m_1=1^{128}$.\\
            \fn02 \> On input $c$, run $\calA(c)$, which outputs
            a bit $d$.\\
            \fn04 \> Output $\bhat=d$.
        \end{tabbing}\end{minipage}
    \end{tabular}
    \end{center}
    Once again, let's check that $\Pr[\ExptOTCPA_\Pi(\calB) = 1]=1$. If $b=0$,
    then the message $m_0=0^{128}$ will be encrypted, and $\calA$ (and hence
    $\calB$) will output $0$. If $m_1=1^{128}$ then the message $m_0=1^{128}$
    will be encrypted, and $\calB$ will end up outputting $1$ for the same
    reason.  Putting these together, $\bhat=b$ with probability $1$.
\end{example}



\subsection{Relation to Perfect Secrecy}

The following theorem formalizes the relationship between one-time CPA
security and perfect secrecy.
\begin{theorem}
    Let $\Pi = (\Enc, \Dec)$ be a deterministic encryption scheme with
    $\msgs = \bits^\ell$ for some integer $\ell$.
    Then $\Pi$ is perfectly secret if and only if for all adversaries
    $\calA$,
    \[
        \AdvOTCPA{\Pi}{\calA} = 0.
    \]
\end{theorem}

We will not prove it formally, but it is important to understand this
intuitively: If all pairs of messages generate ciphertexts with the
same probability, then there is no way to win the experiment with
probability better than random guessing.

\begin{corollary}
    Let $\Piotp = (\Encotp, \Decotp)$ be the $\ell$-bit one-time pad encryption
    scheme. Then for all adversaries $\calA$,
    \[
        \AdvOTCPA{\Piotp}{\calA} = 0,
    \]
    and in other words
    \[
        \Pr[\ExptOTCPA_\Pi(\calA) = 1] = \frac{1}{2}.
    \]
\end{corollary}

%\begin{theorem}
%    Let $G : \bits^n \to \bits^\ell$. Define a deterministic encryption scheme
%    $\Pi = (\Enc, \Dec)$ with key-space $\keys=\bits^n$,
%    message-space $\msgs=\bits^\ell$, and ciphertext-space $\ctxts=\bits^\ell$
%    via
%    \[
%        \Enc(k,m) = G(k)\oplus m, \quad \quad \Dec(k,c) = G(k)\oplus c.
%    \]
%    Then for every adversary $\calA$, there exists another adversary $\calD$,
%    running in about the same time as $\calA$, such that
%    \[
%        \AdvOTCPA{\Pi}{\calA} = \AdvPRG{G}{\calD}.
%    \]
%\end{theorem}
%\begin{proof}
%Build $\calD$ as follows:
%    \begin{center}
%        \begin{tabular}{c}
%            \begin{minipage}{2in}\begin{tabbing}
%                123\=123\=\kill
%                \underline{$\calD(w)$} \\[2pt]
%                \> Run $\calA$, which produces $(m_0,m_1)\in\msgs$\\
%                \> Pick $b\getsr \bits$\\
%                \> Compute $c \gets w\oplus m_b$\\
%                \> Run $\calA(c)$, which produces $\hatb\in\bits$\\
%                \> If $\hatb = b$: Output 1\\
%                \> Else: Output 0
%            \end{tabbing}\end{minipage}
%        \end{tabular}
%    \end{center}
%    \[
%        \Pr[\calD(G(\bK)) = 1] = 
%        \Pr[\ExptOTCPA_\Pi(\calA) = 1]
%    \]
%    \[
%        \Pr[\calD(\bU) = 1] = 
%        \Pr[\ExptOTCPA_{\Piotp}(\calA) = 1] = \frac{1}{2}
%    \]
%    \begin{align*}
%        \AdvPRG{G}{\calD} 
%        & = \left|\Pr[\calD(G(\bK)) = 1] - \Pr[\calD(\bU) = 1]\right| \\
%        & = \left|\Pr[\ExptOTCPA_\Pi(\calA) = 1]
%           -  \Pr[\ExptOTCPA_{\Piotp}(\calA) = 1]\right| \\
%        & = \left|\Pr[\ExptOTCPA_\Pi(\calA) = 1]
%           -  \frac{1}{2}\right| \\
%        & = \AdvOTCPA{\Pi}{\calA}. 
%    \end{align*}
%
%
%\end{proof}
%
%
%\subsection{Defining Assumptions}
%
%\subsection{Proving Security: Reductions}
%
%\section{Step 1: Encryption Security Definition}
%
%\section{Step 2: Assumption: PRG Security of a Stream Cipher}
%
%\section{Step 3: Security Proof via a Reduction}
%
%In this definition we will need the concept of an \emph{oracle} for an
%algorithm.  You can think about oracles intuitively as ``subroutines'' that an
%algorithm can call. When $\calA$ is an oracle algorithm and $O_1$ is a
%function, we write $\calA^{O_1}$ for $\calA$ connected to the oracle
%(subroutine) $O_1$. If $O_2$ is another oracle, we write $\calA^{O_2}$ for
%$\calA$ connected to $O_2$, and so on. 
%
%A key point in this formalism is that $\calA$ can only observe the input/output
%behavior of its oracle, and \emph{not the code implementing the oracle}.  So if
%$O_1$ and $O_2$ are the same function, then $\calA^{O_1}$ and $\calA^{O_2}$
%will behave exactly the same. 


\end{document}

