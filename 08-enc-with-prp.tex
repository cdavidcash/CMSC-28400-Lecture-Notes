\documentclass[11pt]{article}
\usepackage{fullpage}
\usepackage{amsthm}

\usepackage{amsthm,amsmath,amsfonts,amssymb,amstext,enumitem}
\usepackage{latexsym,ifthen,url,rotating,graphicx}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,positioning,fit}
\usepackage{graphicx}
\usepackage[font=small,labelfont=bf]{caption}



% --- -----------------------------------------------------------------
% --- Document-specific definitions.
% --- -----------------------------------------------------------------
\lstset{
    columns=fixed,
    literate={—}{{---}}1 {…}{{...}}1
}

\newcommand{\todo}[1]{{\color{red}[TODO:{#1}]}}

\newtheorem{problem}{Problem}
\newtheorem{corollary}{Corollary}
\newtheorem{fact}{Fact}
\newtheorem{exercise}{Exercise}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{notation}{Notation}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{example}{Example}

\newcommand{\getsr}
  {{\:\stackrel{\raisebox{-2pt}{${\scriptscriptstyle \hspace{0.2em}\$}$}}
   {\leftarrow}\:}}
\newcommand{\points}[1]{\textbf{({#1} pts)}}

\newcommand{\fn}{\footnotesize}
\newcommand{\Colon}{\ : \ }
\newcommand{\st}{\mathsf{state}}
\newcommand{\msgs}{\mathcal{M}}
\newcommand{\ctxts}{\mathcal{C}}
\newcommand{\keys}{\mathcal{K}}
\newcommand{\rands}{\mathcal{R}}
\newcommand{\states}{\mathcal{S}}
\newcommand{\kg}{\mathcal{K}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\MAC}{\mathrm{MAC}}
\newcommand{\RMAC}{\mathrm{RMAC}}

\newcommand{\pk}{pk}
\newcommand{\sk}{sk}

\newcommand{\calD}{\mathcal{D}}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calB}{\mathcal{B}}
\newcommand{\AES}{\mathsf{AES}}

\newcommand{\algorithm}[1]{\textbf{Alg} {#1}}

\newcommand{\calO}{\mathcal{O}}

\newcommand{\dlog}{\mathrm{dlog}}

\newcommand{\Adv}{\mathbf{Adv}}
\newcommand{\AdvPRF}[2]{\Adv^{\mathrm{prf}}_{#1}({#2})}
\newcommand{\AdvPRG}[2]{\Adv^{\mathrm{prg}}_{#1}({#2})}
\newcommand{\AdvCPA}[2]{\Adv^{\mathrm{cpa}}_{#1}({#2})}
\newcommand{\AdvCCA}[2]{\Adv^{\mathrm{cca}}_{#1}({#2})}
\newcommand{\AdvKR}[2]{\Adv^{\mathrm{kr}}_{#1}({#2})}
\newcommand{\AdvCKR}[2]{\Adv^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\AdvRMR}[2]{\Adv^{\mathrm{rmr}}_{#1}({#2})}
\newcommand{\AdvCR}[2]{\Adv^{\mathrm{cr}}_{#1}({#2})}
\newcommand{\AdvUFCMA}[2]{\Adv^{\textrm{uf{-}cma}}_{#1}({#2})}
\newcommand{\AdvDL}[2]{\Adv^{\mathrm{dl}}_{#1}({#2})}

\newcommand{\Exp}{\mathbf{Exp}}
\newcommand{\ExpOW}[1]{\Exp^{\mathrm{ow}}({#1})}
\newcommand{\ExpCKR}[2]{\Exp^{\mathrm{ckr}}_{#1}({#2})}
\newcommand{\ExpRMR}[2]{\Exp^{\mathrm{rmr}}_{#1}({#2})}

\newcommand{\concat}{{\,\|\,}}
\newcommand{\xor}{\oplus}
\newcommand{\bits}{\{0,1\}}

\newcommand{\tcolh}{T^{\mathrm{col}}_h}
\newcommand{\tcolH}{T^{\mathrm{col}}_{H^2}}
\newcommand{\Hcomb}{H^{1\|2}}
\newcommand{\Hxor}{H^{1\oplus2}}

\newcommand{\EXP}{\textrm{EXP}}
\newcommand{\MODEXP}{\textrm{MOD{-}EXP}}
\newcommand{\ADD}{\textrm{ADD}}
\newcommand{\MULTIMODEXP}{\textrm{MULTI{-}MOD{-}EXP}}
\newcommand{\MUL}{\textrm{MUL}}
\newcommand{\MOD}{\textrm{MOD}}

\newcommand{\GG}{\mathbb{G}}
\newcommand{\ZZ}{\mathbb{Z}}

\newcommand{\bK}{\mathbf{K}}
\newcommand{\bof}{\mathbf{f}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bM}{\mathbf{M}}
\newcommand{\bC}{\mathbf{C}}

\newcommand{\rvrange}{\mathcal{R}}
\newcommand{\rspace}{\mathcal{C}}

\newcommand{\hatalpha}{\hat{\alpha}}
\newcommand{\hatb}{\hat{b}}

\newcommand{\barm}{\overline{m}}

\newcommand{\otp}{\mathrm{OTP}}
\newcommand{\des}{\mathrm{DES}}
\newcommand{\twodes}{\mathrm{2DES}}
\newcommand{\threedes}{\mathrm{3DES}}
\newcommand{\threedestwo}{\mathrm{3DES2}}
\newcommand{\aes}{\mathrm{AES}}
\newcommand{\pad}{\mathsf{pad}}
\newcommand{\unpad}{\mathsf{unpad}}


\newcommand{\Img}{\mathrm{Im}}

\newcommand{\Expt}{\mathbf{Expt}}
\newcommand{\ExptOTCPA}{\mathbf{Expt}^{\mathrm{ot\mbox{-}cpa}}}
\newcommand{\ExptOTCPAone}{\mathbf{Expt}^{\mathrm{ot\mbox{-}cpa\mbox{-}1}}}
\newcommand{\ExptOTCPAzero}{\mathbf{Expt}^{\mathrm{ot\mbox{-}cpa\mbox{-}0}}}
\newcommand{\AdvOTCPA}[2]{\Adv^{\mathrm{ot\mbox{-}cpa}}_{#1}({#2})}
\newcommand{\ExptCPAone}{\mathbf{Expt}^{\mathrm{cpa\mbox{-}1}}}
\newcommand{\ExptCPAzero}{\mathbf{Expt}^{\mathrm{cpa\mbox{-}0}}}

\newcommand{\ExptCPA}{\mathbf{Expt}^{\mathrm{cpa}}}
\newcommand{\ExptCCA}{\mathbf{Expt}^{\mathrm{cca}}}
\newcommand{\LR}{\mathrm{LR}}
\newcommand{\Func}{\mathrm{Func}}



\newcommand{\Piotp}{\Pi_\mathrm{otp}}
\newcommand{\Encotp}{\Enc_\mathrm{otp}}
\newcommand{\Decotp}{\Dec_\mathrm{otp}}
\newcommand{\bhat}{\hat{b}}
\newcommand{\Col}{\mathsf{Col}}
% --- -----------------------------------------------------------------
% --- Lecture notes formatting macros
% --- -----------------------------------------------------------------

%
% The following commands set up the lecnum (lecture number)
% counter and make various numbering schemes work relative
% to the lecture number.
%
\newcounter{lecnum}
%\renewcommand{\thepage}{\thelecnum-\arabic{page}}
\renewcommand{\thesection}{\thelecnum.\arabic{section}}
\renewcommand{\theexercise}{\thelecnum.\arabic{exercise}}
\renewcommand{\theexample}{\thelecnum.\arabic{example}}
\renewcommand{\thedefinition}{\thelecnum.\arabic{definition}}
\renewcommand{\theequation}{\thelecnum.\arabic{equation}}
\renewcommand{\thefigure}{\thelecnum.\arabic{figure}}
\renewcommand{\thefact}{\thelecnum.\arabic{fact}}
\renewcommand{\thetable}{\thelecnum.\arabic{table}}


%
% The following macro is used to generate the header.
%
\newcommand{\lecture}[2]{
   %\pagestyle{myheadings}
   %\thispagestyle{plain}
   \newpage
   \setcounter{lecnum}{#1}
   \setcounter{page}{1}
   \noindent
   \begin{center}
   \framebox{
      \vbox{\vspace{2mm}
    \hbox to 6.28in { {\bf CMSC 28400 Introduction to Cryptography
                        \hfill Autumn 2020} }
       \vspace{4mm}
       \hbox to 6.28in { {\Large \hfill #2 \hfill} }
       \vspace{2mm}
       \hbox to 6.28in { {\it Instructor: David Cash} \hfill }
      \vspace{2mm}}
   }
   \end{center}
   %\markboth{Lecture #1: #2}{Lecture #1: #2}
   \vspace*{4mm}
}





% --- -----------------------------------------------------------------
% --- The document starts here.
% --- -----------------------------------------------------------------
\begin{document}
%\lecture{**LECTURE-NUMBER**}{**DATE**}{**LECTURER**}{**SCRIBE**}
\lecture{8}{Notes \#8: Randomized Encryption with a PRP}

todo intro



\section{Symmetric Encryption with the AES Block Cipher}

In this section we give some of the standard constructions of encryption
from a block cipher. For the rest of the section, we fix the block cipher
\[
    \aes :\bits^{128} \times \bits^{128} \to \bits^{128}.
\]

\subsection{Padding}

All of the encryption modes in this section will have message $\msgs$ equal to
arbitrary-length byte strings (that is, bit strings with length a multiple of
$8$).  The AES block cipher we want to work with, however, only accepts exactly
16 bytes as input. Thus at a few points we will need to ``pad'' a string to be
a multiple of 16 bytes long.

At first padding seems easy (``just add zeros'') but in order to be useful
the padding must be reversible, meaning that someone should be able to remove
the padding and arrive at the same message.

To that end, we define a function $\pad$ that accepts a byte-string of
arbitrary length. On input $m$, $\pad(m)$ will add between $1$ and $16$ bytes
(note that it \emph{always} adds at least one byte). To decide how many,
$\pad(m)$ looks at the number of bytes needed to make $m$ a multiple of $16$
bytes long; call this number $N$. If $m$ is already a multiple of 16 bytes
long, it sets $N=16$. Finally $\pad(m)$ adds $N$ bytes with hex value $0xN$.
So if one byte needs to be added, $\pad$ appends $0x01$. If two bytes are
added, then it appends $0x0202$, etc.

\begin{example}
    Suppose $m$ is the byte string 
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01},
    \]
    where the pairs of digits represent bytes in hex.
    This string is $8$ bytes long, so $8$ bytes needed to be added.
    The output of $\pad(m)$ is
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 08\ 08\ 08\ 08\ 08\ 08\ 08\ 08}
    \]
\end{example}

You can check that it is possible to remove the padding from a string
unambiguously. We'll call that function $\unpad$. We note that some strings
have invalid padding, meaning that $\pad$ would never output them.
\begin{example}
    Consider the byte string
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 06\ 06\ 06\ 06\ 05\ 05\ 05\ 05}.
    \]
    This string is not properly padded, because it only ends with $4$ bytes
    with hex value $0x05$ at the end.

    On the other hand, the byte string
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 06\ 06\ 06\ 06\ 05\ 05\ 05\ 01}.
    \]
    \emph{is} properly padded, because it ends in one $0x01$ byte.

    This is somewhat more subtle than it looks at first. The string
    \[
        \mathtt{00\ 00\ 00\ 00\ 01\ 01\ 01\ 01\ 06\ 06\ 06\ 06\ 01\ 01\ 01\ 01}.
    \]
    is also properly padded, because it ends in one $0x01$ byte (the other
    $0x01$ bytes are actually message bytes).
\end{example}
This is called PKCS\#7 padding; You can read about it here, amongst other
places:
\url{https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS#5_and_PKCS#7}.


\subsection{Construction\#1: AES-ECB}

Our first construction isn't randomized or stateful; It's just a plain cipher.
Nonetheless, it is sometimes used, often with catastrophic consequences.

This mode is called \emph{ECB}, for ``electronic codebook.'' 
The key-space is $\keys=\bits^{128}$ and the message-space $\msgs$ is
consists of bytestrings of arbitrary length.
The code is
as follows:
\begin{center}
    \begin{tabular}{c|c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> For $i=1,\ldots,t$:\\
            \> \> $c[i] \gets \aes(k,\barm[i])$\\
            \> $c \gets c[1]\|\ldots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
        &
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Dec(k,m)$}} \\[2pt]
            \> Parse $c[1]\|\ldots\|c[t]\gets c$ \\
            \> For $i=1,\ldots,t$:\\
            \> \> $\barm[i] \gets \aes^{-1}(k,c[i])$\\
            \> $\barm \gets \barm[1]\| \cdots \|\barm[t]$\\
            \> $m \gets \unpad(\barm)$\\
            \> Output $m$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
In words, encryption pads the message $m$ up to a multiple of the
block size, and then parses the padded version into blocks. Then it
applies $\aes$ to each block and concatenates the blocks. Decryption
parses the ciphertext into blocks, and applies $\aes^{-1}$ to each
block, and finally unpads the result.

In a real implementation, the unpadding step may encounter a message that
is not a valid padding (say, if an adversary were to feed in a block that
is mistakenly decrypted). In that case, we should allow $\Dec$ to output
an error symbol instead of $m$.

\subsection{Construction\#2: AES-CBC with Random IV}

The next encryption scheme, called \emph{CBC} for ``cipher block chaining with
a random IV'' is randomized. The term ``IV'' stands for \emph{initialization
vector},  and refers to the randomness used. The code is as follows:

The key-pace and randomness-space for AES-CBC are $\keys=\rands=\bits^{128}$.
The message space is any byte string.
\begin{center}
    \begin{tabular}{c|c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,r)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> $c[0] \gets r$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $c[i] \gets \aes(k,c[i-1]\oplus\barm[i])$\\
            \> $c \gets c[0]\|\ldots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
        &
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Dec(k,m)$}} \\[2pt]
            \> Parse $c[0]\|\ldots\|c[t]\gets c$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $\barm[i] \gets \aes^{-1}(k,c[i])\oplus c[i-1]$\\
            \> $\barm \gets \barm[1]\| \cdots \|\barm[t]$\\
            \> $m \gets \unpad(\barm)$\\
            \> Output $m$ \\ 
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
The encryption algorithm pads the message and parses into blocks. Then
it computes the output $c$ by setting the initial block to $c[0]$,
and the computing the $i$\textsuperscript{th} by XOR-ing the previous
ciphertext block with the current message block, and applying $\aes$.
The ciphertext is the concatenation of the blocks.
Decryption undoes encryption in a direct way. It parses out the ciphertext
blocks, and then recovers the $i$\textsuperscript{th} ciphertext block
by applying $\aes^{-1}$ and XOR-ing with the previous ciphertext block.

What's going on here? CBC is trying to eliminate repeated blocks, and defeat
frequency analysis. Intuitively, if $r$ is chosen randomly, then it should
essentially never repeat. But then the first input, $c[0]\oplus\barm[1]$,
will also essentially never repeat. Then, inductively, we can sort of claim
the same should hold for all of the ciphertext blocks. That's a long way from
a sort of proof, but it is the design rationale.

Finally we note that CBC decryption may also encounter a malformed string when
it attempts to unpad. In that case decryption should throw an error.

\subsection{Construction\#3: AES-CBC with Stateful IV}
Our next cipher is a stateful variant of CBC. It uses its state as the first
ciphertext block, and in this particular version, saves the last ciphertext
block as the new state.
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,s)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> $c[0] \gets s$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $c[i] \gets \aes(k,c[i-1]\oplus\barm[i])$\\
            \> $c \gets c[0]\|\cdots\|c[t]$\\
            \> $s' \gets c[t]$\\
            \> Output $(c,s')$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
Decryption is the same as above and omitted. On the first encryption,
the state is set to a random element of $\bits^{128}$ just like
CBC with a random IV. 

The vague reasoning above about ciphertext blocks not repeating can be applied
here. However, as innocuous as the stateful change may seem, it turns out to be
insecure in most settings where it has been deployed! The attraction is that
the first ciphertext block $c[0]$ can be omitted when it is already known to
the receiver, but the savings comes at a grave cost in security, as we will see.

\subsection{Construction\#4: AES-CTR with Random IV}

The next construction is randomized. It is called \emph{CTR mode}, or
\emph{counter mode}. Compared to CBC with a random IV, it has the advantage of
avoiding padding and thus never encounters mal-formed messages, and produces a
ciphertext exactly 16 bytes longer than its input message.

This construction has $\keys=\rands=\bits^{128}$ and accepts any byte string as
a message. It will do addition with elements of $\bits^{128}$ by treating them
as integers modulo $2^{128}$ (in practice, the wrapping should essentially
never happen though).  The code is as follows:
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,r)$}} \\[2pt]
            \> Parse $m[1]\|\cdots\|m[t]\gets m \quad $ 
                    \emph{//$m[t]$ may be less than $16$ bytes}\\
            \> $c[0] \gets r$ \\
            \> For $i=1,\ldots,t-1$: \\
            \> \> $c[i] \gets \aes(k,r+i\bmod 2^{128})\oplus m[i]$\\
            \> $c[t] \gets \aes(k,r+t\bmod 2^{128})\oplus m[t] \quad$ 
                    \emph{//truncate pad if needed}\\
            \> $c \gets c[0]\|\cdots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
The comment about truncation means that we can only use enough bytes of
$\aes(k,r+t\bmod 2^{128})$ to equal the length of $m[t]$. Intuitively,
CTR mode is simply computing a ``pseudo one-time pad'' by computing
$\aes(k,r+1),\aes(k,r+2),\ldots$ and taking as many bits as needed 
to XOR against the message. 

Decryption does what you'd expect. Note that it needs the value of
$c[0]$ to know where to start computing the pad.
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Dec(k,c)$}} \\[2pt]
            \> Parse $c[0]\|\cdots\|c[t]\gets c \quad $ 
                    \emph{//$c[t]$ may be less than $16$ bytes}\\
            \> $r \gets c[0]$ \\
            \> For $i=1,\ldots,t-1$: \\
            \> \> $m[i] \gets \aes(k,r+i\bmod 2^{128})\oplus c[i]$\\
            \> $m[t] \gets \aes(k,r+t\bmod 2^{128})\oplus c[t] \quad$ 
                    \emph{//truncate pad if needed}\\
            \> $m \gets m[0]\|\cdots\|m[t]$\\
            \> Output $m$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
This is a good cipher, but it may fail if the value of $r$ repeats -- Then
it would effectively reuse a one-time pad.

\subsection{Construction\#5: AES-CTR with Stateful IV}
The final cipher is a variant of CTR that manages state instead of randomness.
It can be run in practice by setting $s=0$ on the first run.
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,s)$}} \\[2pt]
            \> Parse $m[1]\|\cdots\|m[t]\gets m \quad $ 
                    \emph{//$m[t]$ may be less than $16$ bytes}\\
            \> $c[0] \gets s$ \\
            \> For $i=1,\ldots,t-1$: \\
            \> \> $c[i] \gets \aes(k,r+i\bmod 2^{128})\oplus m[i]$\\
            \> $c[t] \gets \aes(k,r+t\bmod 2^{128})\oplus m[t] \quad$ 
                    \emph{//truncate pad if needed}\\
            \> $c \gets c[0]\|\ldots\|c[t]$\\
            \> $s' \gets s+t$\\
            \> Output $(c,s')$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
Decryption is exactly as in CTR with a randomized IV. This version of CTR
has the advantage of never repeating a one-time-pad, as it is effectively
impossible to run the counter until it wraps modulo $2^{128}$.

\begin{exercise}
    Consider the following encryption algorithm:
\begin{center}
    \begin{tabular}{c}
        \begin{minipage}{2in}\begin{tabbing}
            123\=123\=\kill
            \underline{\algorithm{$\Enc(k,m,r)$}} \\[2pt]
            \> $\barm \gets \pad(m)$\\
            \> Parse $\barm[1]\|\cdots\|\barm[t]\gets\barm$ \\
            \> $c[0] \gets r; d[0] \gets r$ \\
            \> For $i=1,\ldots,t$: \\
            \> \> $d[i] \gets \aes(k,d[i-1])$\\
            \> \> $c[i] \gets d[i]\oplus\barm[i]$\\
            \> $c \gets c[0]\|\ldots\|c[t]$\\
            \> Output $c$
        \end{tabbing}\end{minipage}
    \end{tabular}
\end{center}
Find a decryption algorithm for this construction.
\end{exercise}

\end{document}

